쉽게 배우는 알고리즘
Chapter 02
1.	① = X ② = O ③ = X ④ = O

2.	① = O, 이 알고리즘의 점근적 하향은 n**2이다. 즉, n**2보다는 완만하게 증가한다는 것이다. 때문에 O(n**2)는 맞는 말이다.
② = X, 최악의 경우 O(n**2)는 아니다. O-표기법에 따르면 n**2보다 완만하게 증가하는 함수도 포함하고 있으므로 최악의 경우를 표현하고 싶다면 Θ(n**2)라고 해야한다.
③ = O, ②의 근거를 들어 참이다.
④ = O, Θ-표기법은 함수의 증가율이 같다는 것을 의미한다. 평균적인 경우로만 따진다면 충분히 큰 n에 대해서 n log n이 평균이므로 참이다.
⑤ = X, ④에서 기술한대로 평균적인 알고리즘 수행시간은 Θ(n log n)이므로 점근적 하향을 나타내는 ω-표기법을 쓰는 것은 옳지 않다.
⑥ = X, о-표기법은 함수의 증가율보다 완만하다는 것을 의미한다. 이 경우 증가율과 같은 함수는 포함하지 않는다. 때문에 최선의 경우는 n이기 때문에 o(n)는 n의 기울기보다 완만해야 한다. 하지만 이 알고리즘의 최소 수행시간은 n이기 때문에 옳지 않다.

3.	알고리즘의 측면에서는 병합정렬과 퀵정렬, 그리고 수학적인 측면에서는 수학적 귀납법에서 재귀적 성질을 찾을 수 있다.

4.	① = Ο-표기법 ② = Ω-표기법

5.	① = о-표기법, Ο-표기법 ② = Ω-표기법, ω – 표기법

6.	① = a, b, c, d ② = a, b, c, d ③ = b, d, e, f ④ = b, d ⑤ = b, d, e, f ⑥ = b, e ⑦ = b, e

7.	mergeSort 함수 안에 mergeSort(A, p, q); mergeSort(A, q + 1, r); 구문이 있다. 즉, 배열의 중간인 q를 기준으로 배열을 나눈 뒤 나눈 두 배열을 다시 각각 mergeSort하는 것이다. 배열의 크기는 q <- ┖(p + r) / 2로 인하여 1/2, 그리고 1/4로 지수적으로 작아지지만 결국 똑같은 문제를 해결하고 후에 merge(A, p, q, r)하므로 크기만 다르지만 같은 문제를 해결함을 반증한다고 할 수 있다. 즉, n인 배열과 이를 이등분한 배열 간의 관계를 반영하는 것이다. 

8.	C1 = 1, c2 = 5일 때, 모든 n > 0에 대하여 c1*n**2 <= f(n) <= c2 * n**2를 만족하므로 위 식은 참이다. 

9.	n**2

10.	n**3


